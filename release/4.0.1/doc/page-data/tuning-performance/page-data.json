{"componentChunkName":"component---node-modules-carrotsearch-gatsby-plugin-apidocs-dist-templates-documentation-page-js","path":"/tuning-performance/","webpackCompilationHash":"8b506557505bcf0d73c8","result":{"data":{"html":{"frontmatter":{"id":"tuning-performance","title":"Tuning performance"},"html":"<article>\n  <h1>Tuning performance</h1>\n\n  <p id=\"cb67c45a9e4fc89b59a3b99b\">\n    This document presents some hints to improve clustering performance, especially for larger data\n    sets.\n  </p>\n\n  <p id=\"67220509400ce8632eb8d007\">\n    Carrot<sup>2</sup> clustering algorithms have been designed to work really fast\n    but the trade-off is that they store all the data structures in memory.\n    The size of the Java virtual machine's heap will increase quickly\n    with longer overall size of input text. Also, the more documents you put on input and the longer\n    the documents are, the longer the clustering will take.\n  </p>\n\n  <p id=\"2e946ee247f5a25fe1955562\">\n    Below are a few generic guidelines on improving clustering performance.\n  </p>\n\n  <section id=\"reduce-input-size\">\n    <h2>\n        <a class=\"anchor\" href=\"#reduce-input-size\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"/></svg></a>Reduce size of input\n      </h2>\n\n    <p id=\"ec143e7b3f0b6d7f61571b68\">\n      In many cases clustering short document excerpts may work just as well or\n      even better than full documents. Consider the possibility of replacing\n      full content with:\n    </p>\n\n    <ul>\n      <li id=\"71d86e853057cce23e5139c3\">query-matching document fragments (such as search result snippets), if input documents\n        are a result of some type of user-entered query,\n      </li>\n      <li id=\"7f4d966f9a2c795a8907fcdd\">titles and abstracts of documents, if they are available,</li>\n      <li id=\"f99d225fefcb712f4ff12333\">just the leading few sentences or paragraphs of each document.</li>\n    </ul>\n  </section>\n\n  <section id=\"batch-and-merge\">\n    <h2>\n        <a class=\"anchor\" href=\"#batch-and-merge\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"/></svg></a>Batch and merge smaller clustering runs\n      </h2>\n\n    <p id=\"fb1035099d6a4135afd3ea72\">\n      In many cases when the input collection of documents is too large to cluster as a whole,\n      dividing the input into smaller batches (or sampling smaller batches from the input), then\n      clustering separately and finally merging\n      based on cluster label text gives very reasonable results.\n    </p>\n\n    <p id=\"ebd0866847462e1ae74bc429\">\n      The above approach works because cluster labels recurring in smaller batches are very likely\n      to be significant for the entire collection. The downside is that\n      very small clusters containing just a few documents are likely to be lost during this process.\n    </p>\n  </section>\n\n  <section id=\"tune-algorithm\">\n    <h2>\n        <a class=\"anchor\" href=\"#tune-algorithm\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"/></svg></a>Tune algorithm attributes\n      </h2>\n\n    <p id=\"2cfd57667f5df6d210d86566\">\n      In many cases the default attribute settings for each algorithm may not be suitable for very\n      large inputs. Below are some attributes tweak suggestions you should consider. You will\n      likely need to experiment a bit to adjust their values to match the size of your particular input.\n    </p>\n\n    <section>\n      <h3>STC, Bisecting k-Means</h3>\n\n      <section>\n        <h4><code>wordDfThreshold</code></h4>\n\n        <p id=\"7989a11517df728b4088d8f8\">\n          Increase the minimum document frequency (minimum number of occurrences) of terms and phrases\n          to a higher value. Something like 0.5% of the number of documents will typically work. For example, for\n          a document collection of 5000 documents set the attribute to 25.\n        </p>\n      </section>\n    </section>\n\n    <section>\n      <h3>Lingo</h3>\n\n      <section>\n        <h4><code>wordDfThreshold</code>, <code>phraseDfThreshold</code></h4>\n\n        <p id=\"7989a11517df728b4088d8f8_0\">\n          Increase the minimum document frequency (minimum number of occurrences) of terms and phrases\n          to a higher value. Something like 0.5% of the number of documents will typically work. For example, for\n          a document collection of 5000 documents set the attribute to 25.\n        </p>\n      </section>\n\n      <section>\n        <h4><code>factorizationQuality</code></h4>\n\n        <p id=\"5f6d2cf2c1449a744b57cc7f\">\n          For <code>algorithm.matrixReducer.factorizationFactory</code> implementations that support\n          this attribute, lower <code>factorizationQuality</code>. This will cause the\n          matrix factorization algorithm to perform fewer iterations and hence complete quicker.\n        </p>\n        <p id=\"d9fbfcb4ce40df845934312b\">\n          Alternatively, you can set <code>algorithm.matrixReducer.factorizationFactory</code>\n          to an implementation of <code>PartialSingularValueDecompositionFactory</code>, which is\n          slightly faster than the other factorizations and does not have\n          any explicit <code>factorizationQuality</code> attribute.\n        </p>\n      </section>\n\n      <section>\n        <h4><code>maximumMatrixSize</code></h4>\n\n        <p id=\"eb72d6337fded8a0a73c25a9\">\n          Lower maximum matrix size in <code>matrixBuilder</code>. This will cause the matrix\n          factorization algorithm to complete quicker and use less memory. The tradeoff is that with\n          small matrix sizes, Lingo may not be able to discover smaller clusters.\n        </p>\n      </section>\n    </section>\n  </section>\n\n</article>","tableOfContents":[{"heading":"Reduce size of input","anchor":"reduce-input-size"},{"heading":"Batch and merge smaller clustering runs","anchor":"batch-and-merge"},{"heading":"Tune algorithm attributes","anchor":"tune-algorithm"}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/tuning-performance/"}}}