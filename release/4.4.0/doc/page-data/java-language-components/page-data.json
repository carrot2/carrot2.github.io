{
    "componentChunkName": "component---node-modules-carrotsearch-gatsby-theme-apidocs-templates-documentation-page-js",
    "path": "/java-language-components/",
    "result": {"data":{"html":{"frontmatter":{"id":"java-language-components","title":"Language Components"},"html":"<article>\n  <h1>Language Components</h1>\n\n  <p id=\"61916c95\">\n    In this section we describe the role and potential customisation options for language-specific\n    heavyweight components.\n  </p>\n\n  <p id=\"8ba6170c\">\n    <code>LanguageComponent</code> instances provide assistance and hints to improve the\n    quality of clustering for a specific language. The resources associated with this task\n    typically require costly processing to load and parse, so <code>LanguageComponent</code>\n    instances should be <strong>created early and reused for all subsequent clustering\n    calls</strong>.\n  </p>\n\n  <p id=\"9a33dbfe\">\n    A single <code>LanguageComponent</code> instance can provide a number of resources to aid\n    the algorithm in improving clustering quality:\n  </p>\n\n  <ul>\n    <li id=\"a2d28801\">lemmatisation (stemming) routines,</li>\n    <li id=\"bfa6dfd5\">tokenisation (word decomposition) and decompounding routines,</li>\n    <li id=\"867475be\">part of speech dictionaries,</li>\n    <li id=\"b0948e4f\">word or label filters (<a href=\"/dictionaries/\">dictionaries</a>).</li>\n  </ul>\n\n  <p id=\"16589ed8\">\n    The above list is not restricted or complete: each algorithm may require\n    a different set of components to function properly and each language will have a specific set\n    of components that makes sense for that particular language. All available languages\n    and their provided components (interfaces) can be enumerated via service point extension,\n    as shown below.\n  </p>\n\n  <pre><code data-language=\"java\">ServiceLoader&lt;LanguageComponentsProvider&gt; providers =\n    ServiceLoader.load(LanguageComponentsProvider.class);\n\nMap&lt;String, List&lt;LanguageComponentsProvider&gt;&gt; langToProviders = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TreeMap</span>&lt;&gt;();\n<span class=\"hljs-keyword\">for</span> (LanguageComponentsProvider prov : providers) {\n  <span class=\"hljs-keyword\">for</span> (String lang : prov.languages()) {\n    langToProviders.computeIfAbsent(lang, (k) -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;()).add(prov);\n  }\n}\n\nlangToProviders.forEach(\n    (language, provList) -&gt; {\n      System.out.println(<span class=\"hljs-string\">\"  &gt; \"</span> + language);\n      provList.forEach(\n          provider -&gt; {\n            System.out.println(<span class=\"hljs-string\">\"    [Provider: \"</span> + provider.name() + <span class=\"hljs-string\">\"]\"</span>);\n            <span class=\"hljs-keyword\">for</span> (Class&lt;?&gt; componentClass : provider.componentTypes()) {\n              System.out.println(<span class=\"hljs-string\">\"      Component: \"</span> + componentClass.getName());\n            }\n          });\n    });</code></pre>\n\n  <p id=\"f6cd1b97\">\n    x\n    The code above prints the following when executed, revealing providers\n    and components supplied for the English language (other languages omitted):\n  </p>\n\n  <pre><code data-language=\"plaintext\">&gt; English\n  [Provider: Carrot2 Core (Stemmers)]\n    Component: org.carrot2.language.Stemmer\n  [Provider: Carrot2 Core (Tokenizers)]\n    Component: org.carrot2.language.Tokenizer\n  [Provider: Carrot2 Core (Lexical Data)]\n    Component: org.carrot2.language.LabelFilter\n    Component: org.carrot2.language.StopwordFilter\n  [Provider: Carrot2 Core (Label Formatter)]\n    Component: org.carrot2.text.preprocessing.LabelFormatter\n[...]</code></pre>\n\n  <p id=\"47a4c432\">\n    Each of the interfaces of a language component can be\n    overridden. However, for the vast majority of applications\n    only minor tweaks to the defaults are really needed. For example, adding ignorable\n    terms and phrases specific to a given domain is a very helpful step\n    to increase clustering quality\n    (patent documents will have a different lexicon compared to an unrestricted e-mail corpus, for example).\n    Let's take a look at how this is done first.\n  </p>\n\n  <div class=\"warning\" id=\"0e3ecbf6\">\n    <strong>Some algorithms may not support all languages</strong>\n\n    <p id=\"353913fe\">\n      A clustering algorithm in Carrot<sup>2</sup> may support only a subset of the languages\n      available from the <code>LanguageComponentsProvider</code> extension point.\n      Each clustering algorithm has a method called <code>supports(LanguageComponents lc)</code>\n      which can be used to test whether the algorithm works with a given language.\n    </p>\n  </div>\n\n\n\n  <section id=\"tweaking-lexical-filters\">\n    <h2>\n        <a class=\"anchor\" href=\"#tweaking-lexical-filters\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tweaking lexical filters\n      </h2>\n\n    <p id=\"tweaking-lexical-filters:adf5111b\">\n      Lexical filters are responsible for telling the algorithm whether a term or a candidate cluster\n      label should be ignored. Such ignorable elements typically include function\n      words like prepositions, conjunctions or domain-specific boilerplate language that\n      is not a good candidate for a cluster.\n    </p>\n\n    <p id=\"tweaking-lexical-filters:2a6a0897\">\n      The Java API defines two components (interfaces) that are part of each loaded\n      <code>LanguageComponents</code> instance:\n    </p>\n\n    <ul>\n      <li>\n        <p id=\"tweaking-lexical-filters:4674c710\">\n          The <code>StopwordFilter</code> interface controls low-level filtering\n          of individual terms:\n        </p>\n\n        <pre><code data-language=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">StopwordFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Predicate</span>&lt;CharSequence&gt; {\n  <span class=\"hljs-comment\">/**\n   * <span class=\"hljs-doctag\">@param</span> word The word to test. Input words are guaranteed to be in lower case (consistent with\n   *     {<span class=\"hljs-doctag\">@link</span> Character#toLowerCase(int)}.\n   * <span class=\"hljs-doctag\">@return</span> Return {<span class=\"hljs-doctag\">@code</span> false} if the provided term should be ignored in processing.\n   */</span>\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(CharSequence word)</span>;</code></pre>\n      </li>\n\n      <li>\n        <p id=\"tweaking-lexical-filters:e64a44c1\">\n          The <code>LabelFilter</code> interface controls low-level filtering\n          of undesired cluster labels.\n        </p>\n\n        <pre><code data-language=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title class_\">LabelFilter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">Predicate</span>&lt;CharSequence&gt; {\n  <span class=\"hljs-comment\">/**\n   * <span class=\"hljs-doctag\">@param</span> label The label to test. Input labels may have mixed case, depending on the algorithm\n   *     and their surface forms collected from input documents.\n   * <span class=\"hljs-doctag\">@return</span> Return {<span class=\"hljs-doctag\">@code</span> false} if the label candidate should be ignored in processing.\n   */</span>\n  <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(CharSequence label)</span>;</code></pre>\n      </li>\n    </ul>\n\n\n    <p id=\"tweaking-lexical-filters:604df66e\">\n      Both these components can be explicitly provided (or overridden at runtime) in a\n      <code>LanguageComponents</code>\n      instance but implementing a custom filter is often impractical.\n      It is much easier to reuse the default implementation that builds\n      filters using <a href=\"/dictionaries/\">filter dictionaries</a> encoded in JSON.\n    </p>\n\n    <p id=\"tweaking-lexical-filters:5011f64c\">\n      To instantiate <code>LanguageComponents</code> for a particular language with a custom\n      set of dictionary resources, copy the\n      <a href=\"/dictionaries/#location-of-dictionary-files\">default resources</a>\n      shipped with the distribution somewhere where your application\n      can load them.\n    </p>\n\n    <p id=\"tweaking-lexical-filters:411e4f43\">\n      The <code>LanguageComponentsLoader</code> class has a method to provide\n      a custom resource loader (<code>ResourceLookup</code> implementation)\n      responsible for locating any external resources language data may ask for.\n    </p>\n\n    <p id=\"tweaking-lexical-filters:ccde3314\">\n      To restrict the number of loaded resources to only a subset of all available languages\n      (and/ or algorithms), use the loader's <code>limitToLanguages</code> and\n      <code>limitToAlgorithms</code> methods. Here is a full example that\n      loads English resources from a class-relative classpath location:\n    </p>\n\n    <pre><code data-language=\"java\"><span class=\"hljs-type\">LanguageComponents</span> <span class=\"hljs-variable\">custom</span> <span class=\"hljs-operator\">=</span>\n    LanguageComponents.loader()\n        <span class=\"hljs-comment\">// Note we restrict languages to just English because resources for</span>\n        <span class=\"hljs-comment\">// other languages are missing from the location of resource lookup</span>\n        <span class=\"hljs-comment\">// and would have caused an exception.</span>\n        .limitToLanguages(<span class=\"hljs-string\">\"English\"</span>)\n        <span class=\"hljs-comment\">// and we substitute resource lookup locations with our custom location.</span>\n        .withResourceLookup(provider -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ClassRelativeResourceLookup</span>(E03_Languages.class))\n        .load()\n        .language(<span class=\"hljs-string\">\"English\"</span>);</code></pre>\n\n    <p id=\"tweaking-lexical-filters:cb92e62c\">\n      Once loaded, the <code>LanguageComponents</code> object is ready to be used for subsequent\n      clustering calls.\n    </p>\n\n    <p id=\"tweaking-lexical-filters:d7cfec18\">\n      Note that language components loader does not track changes or reload anything\n      automatically (this would be a costly operation). If your lexical resources\n      change often, you'll have to resort to ephemeral dictionaries or\n      a custom implementation of filtering interfaces above.\n    </p>\n  </section>\n\n  <section id=\"ephemeral-dictionaries\">\n    <h2>\n        <a class=\"anchor\" href=\"#ephemeral-dictionaries\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Ephemeral dictionaries (lexical filters)\n      </h2>\n\n    <p id=\"ephemeral-dictionaries:c04d58af\">\n      When filters for labels or stop words change frequently, reloading\n      a full set of dictionaries would be slow and impractical. Ephemeral dictionaries\n      are compiled for each clustering call and layered on top\n      of the default <code>LanguageComponents</code> implementations.\n      Please note that this adds some additional cost to each clustering call.\n    </p>\n\n    <p id=\"ephemeral-dictionaries:5fe338ef\">\n      In the following example, the clustering algorithm uses the default language data for\n      English but adds request-specific regular patterns to exclude undesirable labels:\n    </p>\n\n    <pre><code data-language=\"java\"><span class=\"hljs-comment\">// Load the default dictionaries for English.</span>\n<span class=\"hljs-type\">LanguageComponents</span> <span class=\"hljs-variable\">english</span> <span class=\"hljs-operator\">=</span>\n    LanguageComponents.loader()\n        .limitToLanguages(<span class=\"hljs-string\">\"English\"</span>)\n        .limitToAlgorithms(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LingoClusteringAlgorithm</span>())\n        .load()\n        .language(<span class=\"hljs-string\">\"English\"</span>);\n\n<span class=\"hljs-type\">LingoClusteringAlgorithm</span> <span class=\"hljs-variable\">algorithm</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LingoClusteringAlgorithm</span>();\n\n<span class=\"hljs-comment\">// Create an ephemeral label filter by providing a dictionary with a</span>\n<span class=\"hljs-comment\">// few regexp exclusion patterns.</span>\n<span class=\"hljs-type\">DefaultDictionaryImpl</span> <span class=\"hljs-variable\">labelFilter</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultDictionaryImpl</span>();\nlabelFilter.regexp.set(<span class=\"hljs-string\">\"(?i).*data.*\"</span>, <span class=\"hljs-string\">\"(?i).*mining.*\"</span>);\nalgorithm.dictionaries.labelFilters.set(List.of(labelFilter));</code></pre>\n  </section>\n\n  <section id=\"tweaking-components-directly\">\n    <h2>\n        <a class=\"anchor\" href=\"#tweaking-components-directly\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tweaking <code>LanguageComponents</code>\n      </h2>\n\n    <p id=\"tweaking-components-directly:130014d3\">\n      When the default dictionaries or other components\n      fall short of requirements, a custom replacement may be provided.\n      A <code>LanguageComponents</code> instance consists\n      of a set of interfaces and suppliers providing implementations of these\n      interfaces. We can override any of these suppliers, creating a custom language preprocessing\n      pipeline.\n    </p>\n\n    <p id=\"tweaking-components-directly:13c590f8\">\n      As an example, let's modify the English pipeline to use a custom word stemming component.\n      The supplier for this component always returns the same closure, converting the input to lower\n      case:\n    </p>\n\n    <pre><code data-language=\"java\">Supplier&lt;Stemmer&gt; stemmerSupplier;\nstemmerSupplier = () -&gt; (word) -&gt; word.toString().toLowerCase(Locale.ROOT);</code></pre>\n\n    <p id=\"tweaking-components-directly:057f0963\">\n      We will also replace the default <code>StopwordFilter</code> and <code>LabelFilter</code> components\n      with custom filters based on hardcoded rules:\n    </p>\n\n    <pre><code data-language=\"java\"><span class=\"hljs-comment\">// Ignore words from the list and anything shorter than 4 characters.</span>\n<span class=\"hljs-keyword\">final</span> Set&lt;String&gt; ignored = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;(Arrays.asList(<span class=\"hljs-string\">\"from\"</span>, <span class=\"hljs-string\">\"what\"</span>));\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">StopwordFilter</span> <span class=\"hljs-variable\">wordFilter</span> <span class=\"hljs-operator\">=</span>\n    (word) -&gt; {\n      <span class=\"hljs-comment\">// Ignore any word shorter than 4 characters or on the explicit exclusion list.</span>\n      <span class=\"hljs-keyword\">return</span> word.length() &gt;= <span class=\"hljs-number\">4</span> &amp;&amp; !ignored.contains(word.toString());\n    };\n\n<span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">LabelFilter</span> <span class=\"hljs-variable\">labelFilter</span> <span class=\"hljs-operator\">=</span>\n    (label) -&gt; {\n      <span class=\"hljs-comment\">// Ignore any label that has a substring 'data' in it.</span>\n      <span class=\"hljs-keyword\">return</span> !label.toString().toLowerCase(Locale.ROOT).contains(<span class=\"hljs-string\">\"data\"</span>);\n    };</code></pre>\n\n    <p id=\"tweaking-components-directly:45c49260\">\n      Note how the initialization of the <code>ignored</code> hash set is pulled out of the supplier.\n      The cost of setting up a heavy component (creating the hash set itself in this case) can be high but\n      once set up, suppliers should return instances of the component quickly.\n    </p>\n\n    <p id=\"tweaking-components-directly:5d29701c\">\n      Once we have custom suppliers, overriding their default implementations\n      for English is trivial:\n    </p>\n\n    <pre><code data-language=\"java\"><span class=\"hljs-type\">LanguageComponents</span> <span class=\"hljs-variable\">customized</span> <span class=\"hljs-operator\">=</span>\n    LanguageComponents.loader()\n        .load()\n        .language(<span class=\"hljs-string\">\"English\"</span>)\n        .override(Stemmer.class, stemmerSupplier)\n        <span class=\"hljs-comment\">// Word and label filters are thread-safe here so we</span>\n        <span class=\"hljs-comment\">// supply the same instance all the time.</span>\n        .override(StopwordFilter.class, () -&gt; wordFilter)\n        .override(LabelFilter.class, () -&gt; labelFilter);</code></pre>\n  </section>\n\n  <section id=\"other-languages\">\n    <h2>\n        <a class=\"anchor\" href=\"#other-languages\" aria-hidden=\"true\"><svg aria-hidden=\"true\" height=\"16\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Support for other languages\n      </h2>\n\n    <p id=\"other-languages:12c2c003\">\n      The core Carrot<sup>2</sup> JAR supports only a limited set of popular languages.\n      Additional modules add support for other languages and bring in extra resources required\n      for these languages to work properly.\n    </p>\n\n    <p id=\"other-languages:f43072c0\">\n      All language extensions live under the <code>org.carrot2.lang</code> artifact\n      group namespace. Note that many of them come with sizeable\n      own dependencies like <a href=\"https://lucene.apache.org/\">Apache Lucene</a>\n      analyzers or dictionaries.\n    </p>\n\n    <ul>\n      <li id=\"other-languages:d4637ad3\"><code>carrot2-lang-lucene-chinese</code>: Chinese (traditional\n        and simplified).\n      </li>\n      <li id=\"other-languages:b50e0d49\"><code>carrot2-lang-lucene-japanese</code>: Japanese.</li>\n      <li id=\"other-languages:b1f07318\"><code>carrot2-lang-lucene-korean</code>: Korean.</li>\n      <li id=\"other-languages:41cf0a97\"><code>carrot2-lang-lucene</code>: adds support for many other languages\n        supported by the <a href=\"https://lucene.apache.org/\">Apache Lucene</a> project.\n      </li>\n      <li id=\"other-languages:34eea76b\"><code>carrot2-lang-polish</code>: Polish.</li>\n    </ul>\n\n    <p id=\"other-languages:2451623c\">\n      A language extension is automatically added to the list of supported language components if\n      it can be located and loaded by Java's standard <code>ServiceLoader</code>.\n    </p>\n\n  </section>\n</article>","tableOfContents":[{"heading":"Tweaking lexical filters","anchor":"tweaking-lexical-filters"},{"heading":"Ephemeral dictionaries (lexical filters)","anchor":"ephemeral-dictionaries"},{"heading":"Tweaking LanguageComponents","anchor":"tweaking-components-directly"},{"heading":"Support for other languages","anchor":"other-languages"}]}},"pageContext":{"slug":"/java-language-components/"}},
    "staticQueryHashes": ["2410353295"]}